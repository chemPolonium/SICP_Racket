#lang sicp

(define (make-table)
  (define (node-key node) (car node))
  (define (node-val node) (cadr node))
  (define (node-left node) (caddr node))
  (define (node-right node) (cdddr node))
  (define (set-node-left! node val) (set-car! (cddr node) val))
  (define (set-node-right! node val) (set-cdr! (cddr node) val))
  (define (make-val-pair)
    (cons false nil))
  (define (make-atom-node key)
    (list key (make-val-pair) nil))
  (define (tree-assoc tree key)
    ; tree-node (cons key (cons (cons val sub) (cons left-node right-node)))
    (cond [(null? tree) false]
          [(= key (node-key tree)) tree]
          [(< key (node-key tree)) (tree-assoc (node-left tree) key)]
          [(> key (node-key tree)) (tree-assoc (node-right tree) key)]))
  (define (tree-assoc! tree key)
    (cond [(= key (node-key tree)) tree]
          [(< key (node-key tree))
           (if (null? (node-left tree))
               (let ([new-node (make-atom-node key)])
                 (set-node-left! tree new-node)
                 new-node)
               (tree-assoc! (node-left tree) key))]
          [(> key (node-key tree))
           (if (null? (node-right tree))
               (let ([new-node (make-atom-node key)])
                 (set-node-right! tree new-node)
                 new-node)
               (tree-assoc! (node-right tree) key))]))
  (let ([local-table (list '*table* (list 'base-val))])
    (define (lookup key-list)
      (let loop ([key-list key-list] [this-table local-table])
        (if (null? key-list)
            (car (node-val this-table))
            (let ([subtable (tree-assoc (cdr (node-val this-table))
                                        (car key-list))])
              (and subtable
                   (loop (cdr key-list) subtable))))))
    (define (insert! key-list value)
      (let loop ([key-list key-list] [this-table local-table])
        (if (null? key-list)
            (set-car! (node-val this-table) value)
            (let ([this-key (car key-list)])
              (if (null? (cdr (node-val this-table)))
                  (let ([subtable (make-atom-node this-key)])
                    (set-cdr! (node-val this-table) subtable)
                    (loop (cdr key-list) subtable))
                  (loop (cdr key-list)
                        (tree-assoc! (cdr (node-val this-table))
                                     this-key))))))
      'ok)
    (define (show)
      (display local-table)
      (newline))
    (define (dispatch m)
      (cond [(eq? m 'lookup-proc) lookup]
            [(eq? m 'insert-proc!) insert!]
            [(eq? m 'show-proc) show]
            [else (error "Unknown operation: TABLE" m)]))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
(define show (operation-table 'show-proc))

(put '(1) 3)
(put '(2) 4)
(put '(2 3) 5)
(put '(2 5) 1)
(show)
(get '(1))
(get '(2))
(get '(2 3))
(get '(2 4))
